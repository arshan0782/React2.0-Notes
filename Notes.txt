Introduction to React

ðŸ‘‰ What is React?
React is a JavaScript library for building user interfaces â€” mainly for single-page applications (SPAs).
Developed by Facebook (Meta).

npm create vite@latest myapp --template react
cd myapp
npm install
npm run dev

Functional Component
function Welcome() {
Â  return <h2>Hello from Functional Component</h2>;
}
export default Welcome;

Class Component
import React, { Component } from 'react';
class Welcome extends Component {
Â  render() {
Â    return <h2>Hello from Class Component</h2>;
Â  }
}
export default Welcome;


Props (Properties)
Used to pass data between components.


function Greeting(props) {
Â  return <h3>Hello, {props.name}</h3>;
}

Prop Drilling in React
Prop drilling is the process of passing data from a parent component to deeply nested child components through multiple layers of intermediate components, even if those components donâ€™t need the data themselves.

State
Used to store dynamic data inside components.

import { useState } from 'react';

function Counter() {
Â  const [count, setCount] = useState(0);
Â 
Â  return (
Â    <>
Â      <p>Count: {count}</p>
Â      <button onClick={() => setCount(count + 1)}>+</button>
Â    </>
Â  );
}

React Hooks
Hooks allow functional components to use state and lifecycle methods.

Hook	        Purpose
useState	Manage component state
useEffect	Handle side effects (API calls, DOM updates)
useContext	Manage global context
useRef	        Access DOM elements
useMemo	        Optimize expensive calculations
useCallback	Memoize functions
useReducer	Manage complex state logic

useEffect
import { useState, useEffect } from 'react';

function Timer() {
Â  const [time, setTime] = useState(0);

Â  useEffect(() => {
Â    const timer = setInterval(() => setTime(t => t + 1), 1000);
Â    return () => clearInterval(timer); // cleanup
Â  }, []);

Â  return <h3>Time: {time}s</h3>;
}

Conditional Rendering
function User({ loggedIn }) {
Â  return (
Â    <>
Â      {loggedIn ? <h3>Welcome Back!</h3> : <h3>Please Log In</h3>}
Â    </>
Â  );
}

Lists and Keys
function TodoList() {
Â  const todos = ['Learn React', 'Build Projects', 'Get Job'];
Â  return (
Â    <ul>
Â      {todos.map((todo, index) => <li key={index}>{todo}</li>)}
Â    </ul>
Â  );
}

Forms and Input Handling
function Form() {
Â  const [name, setName] = useState("");

Â  const handleSubmit = (e) => {
Â    e.preventDefault();
Â    alert(`Submitted: ${name}`);
Â  };

Â  return (
Â    <form onSubmit={handleSubmit}>
Â      <input value={name} onChange={(e) => setName(e.target.value)} />
Â      <button type="submit">Submit</button>
Â    </form>
Â  );
}

Fetching API Data
import { useState, useEffect } from 'react';

function Users() {
Â  const [users, setUsers] = useState([]);

Â  useEffect(() => {
Â    fetch("localData.json")
Â      .then(res => res.json())
Â      .then(data => setUsers(data));
Â  }, []);

Â  return (
Â    <ul>
Â      {users.map(user => <li key={user.id}>{user.name}</li>)}
Â    </ul>
Â  );
}

Using try-catch in Async Functions
async function fetchUser() {
Â  try {
Â    const res = await fetch("/api/user");
Â    const data = await res.json();
Â    console.log(data);
Â  } catch (err) {
Â    console.error("Failed to fetch user:", err.message);
Â  }
}

Always catch rejected promises
Display fallback UI if needed
Handling Asynchronous Errors (API / fetch / async-await)
import { useState, useEffect } from "react";

function Users() {
Â  const [users, setUsers] = useState([]);
Â  const [error, setError] = useState(null);

Â  useEffect(() => {
Â    async function fetchData() {
Â      try {
Â        const res = await fetch("https://jsonplaceholder.typicode.com/userss"); // wrong URL
Â        if (!res.ok) throw new Error("Network response not ok");
Â        const data = await res.json();
Â        setUsers(data);
Â      } catch (err) {
Â        setError(err.message);
Â      }
Â    }

Â    fetchData();
Â  }, []);

Â  if (error) return <p>Error: {error}</p>;
Â  return (
Â    <ul>
Â      {users.map((user) => (
Â        <li key={user.id}>{user.name}</li>
Â      ))}
Â    </ul>
Â  );
}

React Router (Navigation)

Install:
npm install react-router-dom

Usage:
import { BrowserRouter, Routes, Route, Link } from "react-router-dom";

function Home() { return <h2>Home Page</h2>; }
function About() { return <h2>About Page</h2>; }

function App() {
Â  return (
Â    <BrowserRouter>
Â      <nav>
Â        <Link to="/">Home</Link> | <Link to="/about">About</Link>
Â      </nav>
Â      <Routes>
Â        <Route path="/" element={<Home />} />
Â        <Route path="/about" element={<About />} />
Â      </Routes>
Â    </BrowserRouter>
Â  );
}

Context API (Global State)
import { createContext, useContext, useState } from "react";

const ThemeContext = createContext();

function App() {
Â  const [theme, setTheme] = useState("light");
Â  return (
Â    <ThemeContext.Provider value={{ theme, setTheme }}>
Â      <Child />
Â    </ThemeContext.Provider>
Â  );
}

function Child() {
Â  const { theme, setTheme } = useContext(ThemeContext);
Â  return (
Â    <>
Â      <h2>Current Theme: {theme}</h2>
Â      <button onClick={() => setTheme("dark")}>Dark Mode</button>
Â    </>
Â  );
}

useReducer Hook
import { useReducer } from "react";

const reducer = (state, action) => {
Â  switch (action.type) {
Â    case "INC": return state + 1;
Â    case "DEC": return state - 1;
Â    default: return state;
Â  }
};

function Counter() {
Â  const [count, dispatch] = useReducer(reducer, 0);
Â  return (
Â    <>
Â      <h3>{count}</h3>
Â      <button onClick={() => dispatch({ type: "INC" })}>+</button>
Â      <button onClick={() => dispatch({ type: "DEC" })}>-</button>
Â    </>
Â  );
}

Custom Hooks
function useFetch(url) {
Â  const [data, setData] = useState(null);
Â  useEffect(() => {
Â    fetch(url).then(res => res.json()).then(setData);
Â  }, [url]);
Â  return data;
}

function Users() {
Â  const users = useFetch("https://jsonplaceholder.typicode.com/users");
Â  return <pre>{JSON.stringify(users, null, 2)}</pre>;
}
The useRef()
Hook is used to store a mutable reference (a value or a DOM element) that persists across re-renders without causing a component to re-render when updated.


useState â†’ re-renders when updated

useRef â†’ does not cause re-render

ðŸ”¹ Syntax
const refContainer = useRef(initialValue);


refContainer.current â†’ stores the current value

The value persists across re-renders

: Accessing DOM Elements

Letâ€™s focus an input field when the button is clicked

import { useRef } from "react";

function InputFocus() {
Â  const inputRef = useRef(null);

Â  const handleFocus = () => {
Â    inputRef.current.focus(); // directly access DOM element
Â  };

Â  return (
Â    <div>
Â      <input ref={inputRef} type="text" placeholder="Enter name" />
Â      <button onClick={handleFocus}>Focus Input</button>
Â    </div>
Â  );
}

export default InputFocus;

What is Destructuring?
Destructuring means unpacking values from arrays or objects into individual variables.
It helps you write cleaner, shorter, and more readable code.

Array Destructuring
const fruits = ["Apple", "Banana", "Mango"];
const [first, second, third] = fruits;

console.log(first);  // Apple
console.log(second); // Banana
console.log(third);  // Mango


Â Without destructuring:

const first = fruits[0];
const second = fruits[1];


Object Destructuring
const user = {
Â  name: "Arshan",
Â  age: 21,
Â  country: "India"
};

const { name, age, country } = user;
console.log(name); // Arshan
console.log(age);  // 21


Without destructuring:
const name = user.name;
const age = user.age;